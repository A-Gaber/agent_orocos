#!/usr/bin/python
import sys

import roslib

import gencpp
import genmsg

from  roslib import packages,msgs
import os

from cStringIO import StringIO

import argparse

import parse_subsystem_xml

def generate_boost_serialization(package, port_def, output_cpp):
    """
    Generate a boost::serialization header

    @param msg_path: The path to the .msg file
    @type msg_path: str
    """
    mc = genmsg.msg_loader.MsgContext()

#    spec = genmsg.msg_loader.load_msg_from_file(mc, msg_path, msg_type)
#    cpp_prefix = '%s::'%(package)

    with open(port_def, 'r') as f:
        read_data = f.read()

    sd = parse_subsystem_xml.parseSubsystemXml(read_data)

    s = StringIO()
    s.write("// autogenerated by rtt_subsystem_ports/create_master_h.py\n")
    s.write("// do not modify this file\n\n")

    header_name = package.upper() + "_MASTER_H__"
    s.write("#ifndef " + header_name + "\n")
    s.write("#define " + header_name + "\n\n")

    s.write("#include \"common_behavior/input_data.h\"\n")
    s.write("#include \"common_behavior/abstract_behavior.h\"\n")
    s.write("#include \"common_behavior/abstract_state.h\"\n\n")


    for p_in in sd.ports_in:
        s.write("#include \"" + p_in.type_pkg + "/" + p_in.type_name + ".h\"\n")

    s.write("\nnamespace " + package + "_types {\n\n")

    #
    # class InputData
    #
    s.write("class InputData : public common_behavior::InputData {\n")
    s.write("public:\n")

    for p_in in sd.ports_in:
        s.write("  " + p_in.type_pkg + "::" + p_in.type_name + " " + p_in.alias + ";\n")

    s.write("};\n\n")

    #
    # errors
    #
    s.write("enum {\n")
    for e in sd.errors:
        s.write("  " + e + "_bit,\n")
    s.write("  ERROR_ENUM_SIZE\n};\n\n")

    s.write("typedef common_behavior::ConditionCause<ERROR_ENUM_SIZE > ErrorCause;\n")
    s.write("typedef boost::shared_ptr<ErrorCause > ErrorCausePtr;\n")
    s.write("typedef boost::shared_ptr<const ErrorCause > ErrorCauseConstPtr;\n\n")

    s.write("std::string getErrorReasonStr(ErrorCauseConstPtr err);\n\n")

    #
    # behavior base class
    #
    s.write("class BehaviorBase : public common_behavior::BehaviorBase {\n")
    s.write("public:\n")
    s.write("  bool checkErrorCondition(\n")
    s.write("      const boost::shared_ptr<common_behavior::InputData >& in_data,\n")
    s.write("      const std::vector<RTT::TaskContext*> &components,\n")
    s.write("      common_behavior::AbstractConditionCausePtr result = common_behavior::AbstractConditionCausePtr()) const {\n")
    s.write("    return checkErrorCondition( boost::static_pointer_cast<InputData >(in_data),\n")
    s.write("                                components,\n")
    s.write("                                boost::dynamic_pointer_cast<ErrorCause >(result) );\n")
    s.write("  }\n\n")

    s.write("  bool checkStopCondition(\n")
    s.write("      const boost::shared_ptr<common_behavior::InputData >& in_data,\n")
    s.write("      const std::vector<RTT::TaskContext*> &components) const {\n")
    s.write("    return checkStopCondition( boost::static_pointer_cast<InputData >(in_data), components);\n")
    s.write("  }\n\n")

    s.write("  virtual bool checkErrorCondition(\n")
    s.write("      const boost::shared_ptr<InputData >& in_data,\n")
    s.write("      const std::vector<RTT::TaskContext*> &components,\n")
    s.write("      ErrorCausePtr result) const = 0;\n\n")

    s.write("  virtual bool checkStopCondition(\n")
    s.write("      const boost::shared_ptr<InputData >& in_data,\n")
    s.write("      const std::vector<RTT::TaskContext*> &components) const = 0;\n\n")

    s.write("protected:\n")
    s.write("  BehaviorBase(const std::string& name, const std::string& short_name)\n")
    s.write("      : common_behavior::BehaviorBase(name, short_name)\n")
    s.write("  { }\n")
    s.write("};\n\n")

    #
    # state base class
    #
    s.write("class StateBase : public common_behavior::StateBase {\n")
    s.write("public:\n")
    s.write("    bool checkInitialCondition(\n")
    s.write("            const boost::shared_ptr<common_behavior::InputData >& in_data,\n")
    s.write("            const std::vector<RTT::TaskContext*> &components,\n")
    s.write("            const std::string& prev_state_name,\n")
    s.write("            bool in_error) const {\n")
    s.write("        return checkInitialCondition(boost::static_pointer_cast<InputData >(in_data), components, prev_state_name, in_error);\n")
    s.write("    }\n\n")

    s.write("    virtual bool checkInitialCondition(\n")
    s.write("            const boost::shared_ptr<InputData >& in_data,\n")
    s.write("            const std::vector<RTT::TaskContext*> &components,\n")
    s.write("            const std::string& prev_state_name,\n")
    s.write("            bool in_error) const = 0;\n\n")

    s.write("protected:\n")
    s.write("    StateBase(const std::string& state_name, const std::string& short_state_name, const std::string& behavior_name) :\n")
    s.write("        common_behavior::StateBase(state_name, short_state_name, behavior_name)\n")
    s.write("    { }\n")
    s.write("};\n")

    s.write("};  // namespace " + package + "_types\n\n")

    s.write("#endif  // " + header_name + "\n")

    (output_dir,filename) = os.path.split(output_cpp)
    try:
        os.makedirs(output_dir)
    except OSError, e:
        pass

    f = open(output_cpp, 'w')
    print >> f, s.getvalue()

    s.close()


def create_boost_headers(argv, stdout, stderr):
    parser = argparse.ArgumentParser(description='Generate boost serialization header for ROS message.')
    parser.add_argument('pkg',metavar='PKG',type=str, nargs=1,help='The package name.')
    parser.add_argument('port_def',metavar='PORT_DEF',type=str, nargs=1,help='Port definition file.')
    parser.add_argument('output_cpp',metavar='OUTPUT_CPP',type=str, nargs=1,help='Output cpp file.')

    args = parser.parse_args()

    print args.pkg[0], args.port_def[0], args.output_cpp[0]

    generate_boost_serialization(args.pkg[0], args.port_def[0], args.output_cpp[0])

if __name__ == "__main__":
    try:
        create_boost_headers(sys.argv, sys.stdout, sys.stderr)
    except Exception, e:
        sys.stderr.write("Failed to generate boost headers: " + str(e))
        raise
        #sys.exit(1)
