#!/usr/bin/python
import sys

import roslib

import gencpp
import genmsg

from  roslib import packages,msgs
import os

from cStringIO import StringIO

import argparse

import parse_subsystem_xml

def generate_boost_serialization(package, port_def, output_cpp):
    """
    Generate a boost::serialization header

    @param msg_path: The path to the .msg file
    @type msg_path: str
    """
    mc = genmsg.msg_loader.MsgContext()

    with open(port_def, 'r') as f:
        read_data = f.read()

    sd = parse_subsystem_xml.parseSubsystemXml(read_data)

    s = StringIO()
    s.write("// autogenerated by rtt_subsystem_ports/create_master_h.py\n")
    s.write("// do not modify this file\n\n")

    s.write("#include \"common_behavior/input_data.h\"\n")
    s.write("#include \"common_behavior/abstract_behavior.h\"\n")
    s.write("#include \"common_behavior/abstract_predicate_list.h\"\n\n")


    for p_in in sd.ports_in:
        s.write("#include \"" + p_in.type_pkg + "/" + p_in.type_name + ".h\"\n")

    s.write("\nnamespace " + package + "_types {\n\n")

    s.write("#include <shm_comm/shm_channel.h>\n")
    s.write("#include <vector>\n")
    s.write("#include <string>\n")
    s.write("#include <rtt/RTT.hpp>\n")
    s.write("#include <rtt/Logger.hpp>\n")
    s.write("#include <rtt_rosclock/rtt_rosclock.h>\n\n")

    s.write("using namespace RTT;\n\n")

    s.write("class InputBuffers: public RTT::TaskContext {\n")
    s.write("public:\n")
    s.write("    explicit InputBuffers(const std::string& name)\n")
    s.write("        : TaskContext(name, PreOperational)\n")
    for p in sd.ports_in:
#        s.write("        , shm_name_" + p.alias + "_()\n")
        s.write("        , buf_prev_" + p.alias + "_(NULL)\n")
        s.write("        , port_" + p.alias + "_out_(\"" + p.alias + "_OUTPORT\", false)\n")
    s.write("        , trigger_out_(\"trigger_OUTPORT\")
#    s.write("        , event_(false)
#TODO:
    s.write("        , period_min_(0.0)\n")
    s.write("        , period_avg_(0.0)\n")
    s.write("        , period_max_(0.0)\n")
    s.write("    {\n")
    for p in sd.ports_in:
        s.write("        this->ports()->addPort(port_" + p.alias + "_out_);\n")
    s.write("        this->ports()->addPort(trigger_out_);\n")

    s.write("        this->addOperation(\"getDiag\", &InputBuffers::getDiag, this, RTT::ClientThread);\n")

#    s.write("        addProperty("event", event_);
#TODO:
#        addProperty("period_min", period_min_);
#        addProperty("period_avg", period_avg_);
#        addProperty("period_max", period_max_);

    for p in sd.ports_in:
        s.write("        addProperty(\"channel_name" + p.alias + "\", param_channel_name_" + p.alias + "_);\n")
    s.write("    }\n\n")

    s.write("    // this method in not RT-safe\n")
    s.write("    std::string getDiag() {\n")
    s.write("        std::stringstream ss;\n")
#TODO:
#    s.write("        if (diag_buf_valid_) {\n")
#    s.write("            //ros::message_operations::Printer<Container >::stream(ss, "", diag_buf_);\n")
#    s.write("            ss << "<data ok>";\n")
#    s.write("        }\n")
#    s.write("        else {\n")
#    s.write("            ss << "<no data>";\n")
#    s.write("            RTT::os::TimeService::Seconds last_recv_sec = RTT::nsecs_to_Seconds(last_recv_time_);\n")
#    s.write("            RTT::os::TimeService::Seconds now_sec = RTT::nsecs_to_Seconds(RTT::os::TimeService::Instance()->getNSecs());\n")
#    s.write("            RTT::Seconds interval = now_sec - last_recv_sec;\n")
#    s.write("            ss << ", <for: " << interval << "s>";\n")
#    s.write("        }\n")
    s.write("        return ss.str();\n")
    s.write("    }\n\n")

    s.write("    bool configureHook() {\n")
    s.write("        Logger::In in(\"" + package + "::InputBuffers::configureHook\");\n")
    s.write("        if (param_channel_name_.empty()) {\n")
    s.write("            Logger::log() << Logger::Error << "parameter \'channel_name\' is empty" << Logger::endl;\n")
    s.write("            return false;\n")
    s.write("        }\n")

#TODO:
#        if (event_) {
#            if (period_min_ == 0.0) {
#                Logger::log() << Logger::Error << "parameter \'period_min\' is not set (0.0)" << Logger::endl;
#                return false;
#            }
#            if (period_avg_ == 0.0) {
#                Logger::log() << Logger::Error << "parameter \'period_avg\' is not set (0.0)" << Logger::endl;
#                return false;
#            }
#            if (period_max_ == 0.0) {
#                Logger::log() << Logger::Error << "parameter \'period_max\' is not set (0.0)" << Logger::endl;
#                return false;
#            }

#            if (period_min_ >= period_avg_) {
#                Logger::log() << Logger::Error << "parameter \'period_min\' should be < than \'period_avg\': " << period_min_ << ", " << period_avg_ << Logger::endl;
#                return false;
#            }
#            if (period_avg_ >= period_max_) {
#                Logger::log() << Logger::Error << "parameter \'period_avg_\' should be < than \'period_max_\': " << period_avg_ << ", " << period_max_ << Logger::endl;
#                return false;
#            }
#        }

    s.write("        Logger::log() << Logger::Info << \"parameter channel_name is set to: \\\'\" << param_channel_name_ << \"\\\'\" << Logger::endl;\n")
#TODO:
#        Logger::log() << Logger::Info << "parameter event is set to: \'" << (event_?"true":"false") << Logger::endl;
#        Logger::log() << Logger::Info << "parameter \'period_min\' is set to: " << period_min_ << Logger::endl;
#        Logger::log() << Logger::Info << "parameter \'period_avg\' is set to: " << period_avg_ << Logger::endl;
#        Logger::log() << Logger::Info << "parameter \'period_max\' is set to: " << period_max_ << Logger::endl;

    s.write("        shm_name_ = param_channel_name_;\n")

    s.write("        bool create_channel = false;\n")

        int result = shm_connect_reader(shm_name_.c_str(), &re_);
        if (result == SHM_INVAL) {
            Logger::log() << Logger::Error << "shm_connect_reader: invalid parameters" << Logger::endl;
            return false;
        }
        else if (result == SHM_FATAL) {
            Logger::log() << Logger::Error << "shm_connect_reader: memory error" << Logger::endl;
            return false;
        }
        else if (result == SHM_NO_CHANNEL) {
            Logger::log() << Logger::Warning << "shm_connect_reader: could not open shm object, trying to initialize the channel..." << Logger::endl;
            create_channel = true;
        }
        else if (result == SHM_CHANNEL_INCONSISTENT) {
            Logger::log() << Logger::Warning << "shm_connect_reader: shm channel is inconsistent, trying to initialize the channel..." << Logger::endl;
            create_channel = true;
        }
        else if (result == SHM_ERR_INIT) {
            Logger::log() << Logger::Error << "shm_connect_reader: could not initialize channel" << Logger::endl;
            return false;
        }
        else if (result == SHM_ERR_CREATE) {
            Logger::log() << Logger::Warning << "shm_connect_reader: could not create reader" << Logger::endl;
            create_channel = true;
        }

        if (!create_channel) {
            void *pbuf = NULL;
            result = shm_reader_buffer_get(re_, &pbuf);
            if (result < 0) {
                Logger::log() << Logger::Warning << "shm_reader_buffer_get: error: " << result << Logger::endl;
                create_channel = true;
            }
        }

        if (create_channel) {
            result = shm_create_channel(shm_name_.c_str(), sizeof(Container), 1, true);
            if (result != 0) {
                Logger::log() << Logger::Error << "create_shm_object: error: " << result << "   errno: " << errno << Logger::endl;
                return false;
            }

            result = shm_connect_reader(shm_name_.c_str(), &re_);
            if (result != 0) {
                Logger::log() << Logger::Error << "shm_connect_reader: error: " << result << Logger::endl;
                return false;
            }
        }

        mTriggerOnStart = false;

        return true;
    }

    void cleanupHook() {
        shm_release_reader(re_);
    }

    void stopHook() {
        if (getTaskState() == TaskContext::Exception || getTaskState() == TaskContext::RunTimeError) {
            recover();
        }
    }

    bool startHook() {
        void *pbuf = NULL;

        int result = 0;
        result = shm_reader_buffer_get(re_, &pbuf);

        if (result < 0) {
            Logger::log() << Logger::Error << "shm_reader_buffer_get: error: " << result << Logger::endl;
            return false;
        }

        buf_prev_ = reinterpret_cast<Container*>( pbuf );

        diag_buf_valid_ = false;
        trigger();

        last_read_successful_ = false;

        return true;
    }

    void exceptionHook() {
        recover();
    }

    void updateHook() {

        // get update time
        ros::Time update_time = rtt_rosclock::host_now();
        timespec ts;
        clock_gettime(CLOCK_REALTIME, &ts);

        void *pbuf = NULL;
        Container *buf = NULL;

        if (event_) {
            double timeout_s;
            if (last_read_successful_) {
                timeout_s = period_max_;
            }
            else {
                timeout_s = period_avg_;
            }

            int timeout_sec = (int)timeout_s;
            int timeout_nsec = (int)((timeout_s - (double)timeout_sec) * 1000000000.0);

            ts.tv_sec += timeout_sec;
            ts.tv_nsec += timeout_nsec;
            if (ts.tv_nsec >= 1000000000) {
                ts.tv_nsec -= 1000000000;
                ++ts.tv_sec;
            }

            int read_status = shm_reader_buffer_timedwait(re_, &ts, &pbuf);

            ros::Time read_time = rtt_rosclock::host_now();
            double read_interval = (read_time - update_time).toSec();

            if (read_status == SHM_TIMEOUT) {
                diag_buf_valid_ = false;
                last_read_successful_ = false;
                no_data_out_.write(true);
                // do not wait
            }
            else if (read_status == 0 && ((buf = reinterpret_cast<Container*>( pbuf )) != buf_prev_)) {
                diag_buf_valid_ = true;
                last_read_successful_ = true;
                // save the pointer of buffer
                buf_prev_ = buf;
                port_msg_out_.write(*buf);
                if (read_interval < period_min_) {
                    usleep( int((period_min_ - read_interval)*1000000.0) );
                }
            }
            else if (read_status > 0) {
                diag_buf_valid_ = false;
                last_read_successful_ = false;
                no_data_out_.write(true);
                if (read_interval < period_avg_) {
                    usleep( int((period_avg_ - read_interval)*1000000.0) );
                }
            }
            else {
                diag_buf_valid_ = false;
                Logger::log() << Logger::Error << getName() << " shm_reader_buffer_timedwait status: " << read_status << Logger::endl;
                error();
                return;
            }
        }
        else {
            double timeout_s = 1.0;

            int timeout_sec = (int)timeout_s;
            int timeout_nsec = (int)((timeout_s - (double)timeout_sec) * 1000000000.0);

            ts.tv_sec += timeout_sec;
            ts.tv_nsec += timeout_nsec;
            if (ts.tv_nsec >= 1000000000) {
                ts.tv_nsec -= 1000000000;
                ++ts.tv_sec;
            }

            int read_status = shm_reader_buffer_timedwait(re_, &ts, &pbuf);

            if (read_status == SHM_TIMEOUT) {
                diag_buf_valid_ = false;
            }
            else if (read_status == 0 && ((buf = reinterpret_cast<Container*>( pbuf )) != buf_prev_)) {
                diag_buf_valid_ = true;
                // save the pointer of buffer
                buf_prev_ = buf;
                port_msg_out_.write(*buf);
            }
            else if (read_status > 0) {
                diag_buf_valid_ = false;
            }
            else {
                diag_buf_valid_ = false;
                Logger::log() << Logger::Error << getName() << " shm_reader_buffer_timedwait status: " << read_status << Logger::endl;
                error();
                return;
            }

        }

        trigger();
    }

private:

    // properties
    std::string param_channel_name_;

    bool event_;
    double period_min_;
    double period_avg_;
    double period_max_;

    std::string shm_name_;

    shm_reader_t* re_;
    Container *buf_prev_;
    bool last_read_successful_;

    RTT::OutputPort<Container > port_msg_out_;

    RTT::OutputPort<bool > no_data_out_;

    bool diag_buf_valid_;

    RTT::os::TimeService::nsecs last_recv_time_;

    ros::Time last_update_time_;
};




    s.write("};  // namespace " + package + "_types\n\n")

    (output_dir,filename) = os.path.split(output_cpp)
    try:
        os.makedirs(output_dir)
    except OSError, e:
        pass

    f = open(output_cpp, 'w')
    print >> f, s.getvalue()

    s.close()


def create_boost_headers(argv, stdout, stderr):
    parser = argparse.ArgumentParser(description='Generate boost serialization header for ROS message.')
    parser.add_argument('pkg',metavar='PKG',type=str, nargs=1,help='The package name.')
    parser.add_argument('port_def',metavar='PORT_DEF',type=str, nargs=1,help='Port definition file.')
    parser.add_argument('output_cpp',metavar='OUTPUT_CPP',type=str, nargs=1,help='Output cpp file.')

    args = parser.parse_args()

    print args.pkg[0], args.port_def[0], args.output_cpp[0]

    generate_boost_serialization(args.pkg[0], args.port_def[0], args.output_cpp[0])

if __name__ == "__main__":
    try:
        create_boost_headers(sys.argv, sys.stdout, sys.stderr)
    except Exception, e:
        sys.stderr.write("Failed to generate boost headers: " + str(e))
        raise
        #sys.exit(1)
