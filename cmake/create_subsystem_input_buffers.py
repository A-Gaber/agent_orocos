#!/usr/bin/python
import sys

import roslib

import gencpp
import genmsg

from  roslib import packages,msgs
import os

from cStringIO import StringIO

import argparse

import parse_subsystem_xml

def generate_boost_serialization(package, port_def, output_cpp):
    """
    Generate a boost::serialization header

    @param msg_path: The path to the .msg file
    @type msg_path: str
    """
    mc = genmsg.msg_loader.MsgContext()

    with open(port_def, 'r') as f:
        read_data = f.read()

    sd = parse_subsystem_xml.parseSubsystemXml(read_data)

    s = StringIO()
    s.write("// autogenerated by rtt_subsystem_ports/create_master_h.py\n")
    s.write("// do not modify this file\n\n")

    s.write("#include \"common_behavior/input_data.h\"\n")
    s.write("#include \"common_behavior/abstract_behavior.h\"\n")
    s.write("#include \"common_behavior/abstract_predicate_list.h\"\n\n")

    for p_in in sd.ports_in:
        s.write("#include \"" + p_in.type_pkg + "/" + p_in.type_name + ".h\"\n")

    s.write("#include <shm_comm/shm_channel.h>\n")
    s.write("#include <vector>\n")
    s.write("#include <string>\n")
    s.write("#include <rtt/RTT.hpp>\n")
    s.write("#include <rtt/Logger.hpp>\n")
    s.write("#include <rtt/Component.hpp>\n")
    s.write("#include <rtt_rosclock/rtt_rosclock.h>\n\n")

    s.write("using namespace RTT;\n\n")

    s.write("\nnamespace " + package + "_types {\n\n")


    s.write("class InputBuffers: public RTT::TaskContext {\n")
    s.write("public:\n")
    s.write("    explicit InputBuffers(const std::string& name)\n")
    s.write("        : TaskContext(name, PreOperational)\n")
    for p in sd.ports_in:
#        s.write("        , shm_name_" + p.alias + "_()\n")
        s.write("        , buf_prev_" + p.alias + "_(NULL)\n")
        s.write("        , port_" + p.alias + "_out_(\"" + p.alias + "_OUTPORT\", false)\n")
    s.write("        , trigger_out_(\"trigger_OUTPORT\")\n")
#    s.write("        , event_(false)
#TODO:
    if sd.trigger.buffer_aliases:
        s.write("        , period_min_(" + str(sd.trigger.period_min) + ")\n")
        s.write("        , period_avg_(" + str(sd.trigger.period_avg) + ")\n")
        s.write("        , period_max_(" + str(sd.trigger.period_max) + ")\n")
        s.write("        , period_sim_max_(" + str(sd.trigger.period_sim_max) + ")\n")
    s.write("    {\n")
    for p in sd.ports_in:
        s.write("        this->ports()->addPort(port_" + p.alias + "_out_);\n")
    s.write("        this->ports()->addPort(trigger_out_);\n")

    s.write("        this->addOperation(\"getDiag\", &InputBuffers::getDiag, this, RTT::ClientThread);\n")

#    s.write("        addProperty("event", event_);
#TODO:
#        addProperty("period_min", period_min_);
#        addProperty("period_avg", period_avg_);
#        addProperty("period_max", period_max_);

    for p in sd.ports_in:
        s.write("        addProperty(\"channel_name_" + p.alias + "\", param_channel_name_" + p.alias + "_);\n")
    s.write("    }\n\n")

    s.write("    // this method in not RT-safe\n")
    s.write("    std::string getDiag() {\n")
    s.write("        std::stringstream ss;\n")
#TODO:
#    s.write("        if (diag_buf_valid_) {\n")
#    s.write("            //ros::message_operations::Printer<Container >::stream(ss, "", diag_buf_);\n")
#    s.write("            ss << "<data ok>";\n")
#    s.write("        }\n")
#    s.write("        else {\n")
#    s.write("            ss << "<no data>";\n")
#    s.write("            RTT::os::TimeService::Seconds last_recv_sec = RTT::nsecs_to_Seconds(last_recv_time_);\n")
#    s.write("            RTT::os::TimeService::Seconds now_sec = RTT::nsecs_to_Seconds(RTT::os::TimeService::Instance()->getNSecs());\n")
#    s.write("            RTT::Seconds interval = now_sec - last_recv_sec;\n")
#    s.write("            ss << ", <for: " << interval << "s>";\n")
#    s.write("        }\n")
    s.write("        return ss.str();\n")
    s.write("    }\n\n")

    s.write("    bool configureHook() {\n")
    s.write("        Logger::In in(\"" + package + "::InputBuffers::configureHook\");\n")
    for p in sd.ports_in:
        s.write("        if (param_channel_name_" + p.alias + "_.empty()) {\n")
        s.write("            Logger::log() << Logger::Error << \"parameter \\\'channel_name_" + p.alias + "\\\' is empty\" << Logger::endl;\n")
        s.write("            return false;\n")
        s.write("        }\n")
        s.write("        Logger::log() << Logger::Info << \"parameter channel_name is set to: \\\'\" << param_channel_name_" + p.alias + "_ << \"\\\'\" << Logger::endl;\n")

#TODO:
#        if (event_) {
#            if (period_min_ == 0.0) {
#                Logger::log() << Logger::Error << "parameter \'period_min\' is not set (0.0)" << Logger::endl;
#                return false;
#            }
#            if (period_avg_ == 0.0) {
#                Logger::log() << Logger::Error << "parameter \'period_avg\' is not set (0.0)" << Logger::endl;
#                return false;
#            }
#            if (period_max_ == 0.0) {
#                Logger::log() << Logger::Error << "parameter \'period_max\' is not set (0.0)" << Logger::endl;
#                return false;
#            }

#            if (period_min_ >= period_avg_) {
#                Logger::log() << Logger::Error << "parameter \'period_min\' should be < than \'period_avg\': " << period_min_ << ", " << period_avg_ << Logger::endl;
#                return false;
#            }
#            if (period_avg_ >= period_max_) {
#                Logger::log() << Logger::Error << "parameter \'period_avg_\' should be < than \'period_max_\': " << period_avg_ << ", " << period_max_ << Logger::endl;
#                return false;
#            }
#        }

#TODO:
#        Logger::log() << Logger::Info << "parameter event is set to: \'" << (event_?"true":"false") << Logger::endl;
#        Logger::log() << Logger::Info << "parameter \'period_min\' is set to: " << period_min_ << Logger::endl;
#        Logger::log() << Logger::Info << "parameter \'period_avg\' is set to: " << period_avg_ << Logger::endl;
#        Logger::log() << Logger::Info << "parameter \'period_max\' is set to: " << period_max_ << Logger::endl;

    s.write("        bool create_channel;\n")
    s.write("        int result;\n")

    for p in sd.ports_in:
        s.write("        shm_name_" + p.alias + "_ = param_channel_name_" + p.alias + "_;\n")
        s.write("        create_channel = false;\n")

        s.write("        result = shm_connect_reader(shm_name_" + p.alias + "_.c_str(), &re_" + p.alias + "_);\n")
        s.write("        if (result == SHM_INVAL) {\n")
        s.write("            Logger::log() << Logger::Error << \"shm_connect_reader: invalid parameters\" << Logger::endl;\n")
        s.write("            return false;\n")
        s.write("        }\n")
        s.write("        else if (result == SHM_FATAL) {\n")
        s.write("            Logger::log() << Logger::Error << \"shm_connect_reader: memory error\" << Logger::endl;\n")
        s.write("            return false;\n")
        s.write("        }\n")
        s.write("        else if (result == SHM_NO_CHANNEL) {\n")
        s.write("            Logger::log() << Logger::Warning << \"shm_connect_reader: could not open shm object, trying to initialize the channel...\" << Logger::endl;\n")
        s.write("            create_channel = true;\n")
        s.write("        }\n")
        s.write("        else if (result == SHM_CHANNEL_INCONSISTENT) {\n")
        s.write("            Logger::log() << Logger::Warning << \"shm_connect_reader: shm channel is inconsistent, trying to initialize the channel...\" << Logger::endl;\n")
        s.write("            create_channel = true;\n")
        s.write("        }\n")
        s.write("        else if (result == SHM_ERR_INIT) {\n")
        s.write("            Logger::log() << Logger::Error << \"shm_connect_reader: could not initialize channel\" << Logger::endl;\n")
        s.write("            return false;\n")
        s.write("        }\n")
        s.write("        else if (result == SHM_ERR_CREATE) {\n")
        s.write("            Logger::log() << Logger::Warning << \"shm_connect_reader: could not create reader\" << Logger::endl;\n")
        s.write("            create_channel = true;\n")
        s.write("        }\n")

        s.write("        if (!create_channel) {\n")
        s.write("            void *pbuf = NULL;\n")
        s.write("            result = shm_reader_buffer_get(re_" + p.alias + "_, &pbuf);\n")
        s.write("            if (result < 0) {\n")
        s.write("                Logger::log() << Logger::Warning << \"shm_reader_buffer_get: error: \" << result << Logger::endl;\n")
        s.write("                create_channel = true;\n")
        s.write("            }\n")
        s.write("        }\n")

        s.write("        if (create_channel) {\n")
        s.write("            result = shm_create_channel(shm_name_" + p.alias + "_.c_str(), sizeof(" + p.getTypeCpp() + "), 1, true);\n")
        s.write("            if (result != 0) {\n")
        s.write("                Logger::log() << Logger::Error << \"create_shm_object: error: \" << result << \"   errno: \" << errno << Logger::endl;\n")
        s.write("                return false;\n")
        s.write("            }\n")

        s.write("            result = shm_connect_reader(shm_name_" + p.alias + "_.c_str(), &re_" + p.alias + "_);\n")
        s.write("            if (result != 0) {\n")
        s.write("                Logger::log() << Logger::Error << \"shm_connect_reader: error: \" << result << Logger::endl;\n")
        s.write("                return false;\n")
        s.write("            }\n")
        s.write("        }\n")

    s.write("        mTriggerOnStart = false;\n")
    s.write("        return true;\n")
    s.write("    }\n\n")

    s.write("    void cleanupHook() {\n")
    for p in sd.ports_in:
        s.write("        shm_release_reader(re_" + p.alias + "_);\n")
    s.write("    }\n\n")

    s.write("    void stopHook() {\n")
    s.write("        if (getTaskState() == TaskContext::Exception || getTaskState() == TaskContext::RunTimeError) {\n")
    s.write("            recover();\n")
    s.write("        }\n")
    s.write("    }\n\n")

    s.write("    bool startHook() {\n")
    s.write("        void *pbuf = NULL;\n")
    s.write("        int result;\n")
    for p in sd.ports_in:
        s.write("        result = shm_reader_buffer_get(re_" + p.alias + "_, &pbuf);\n")
        s.write("        if (result < 0) {\n")
        s.write("            Logger::log() << Logger::Error << \"shm_reader_buffer_get(" + p.alias + "): error: \" << result << Logger::endl;\n")
        s.write("            return false;\n")
        s.write("        }\n")
        s.write("        buf_prev_" + p.alias + "_ = reinterpret_cast<" + p.getTypeCpp() + "*>( pbuf );\n")

    s.write("        diag_buf_valid_ = false;\n")
    s.write("        trigger();\n")
    s.write("        last_read_successful_ = false;\n")
    s.write("        return true;\n")
    s.write("    }\n\n")

    s.write("    void exceptionHook() {\n")
    s.write("        recover();\n")
    s.write("    }\n\n")

    s.write("    void updateHook() {\n")
    s.write("        // get update time\n")
    s.write("        ros::Time update_time = rtt_rosclock::host_now();\n")
    s.write("        timespec ts;\n")
    s.write("        clock_gettime(CLOCK_REALTIME, &ts);\n")
    s.write("        int read_status;\n")

    if sd.trigger.buffer_aliases:
        s.write("        double timeout_s;\n")
        s.write("        if (last_read_successful_) {\n")
        s.write("            timeout_s = period_max_;\n")
        s.write("        }\n")
        s.write("        else {\n")
        s.write("            timeout_s = period_avg_;\n")
        s.write("        }\n")
        s.write("        int timeout_sec = (int)timeout_s;\n")
        s.write("        int timeout_nsec = (int)((timeout_s - (double)timeout_sec) * 1000000000.0);\n")
        s.write("        ts.tv_sec += timeout_sec;\n")
        s.write("        ts.tv_nsec += timeout_nsec;\n")
        s.write("        if (ts.tv_nsec >= 1000000000) {\n")
        s.write("            ts.tv_nsec -= 1000000000;\n")
        s.write("            ++ts.tv_sec;\n")
        s.write("        }\n")
        s.write("        int usleep_time = 0;\n")
        for p in sd.ports_in:
            if p.alias in sd.trigger.buffer_aliases:
                s.write("      {\n")
                s.write("        void *pbuf = NULL;\n")
                s.write("        " + p.getTypeCpp() + " *buf = NULL;\n")
                s.write("        read_status = shm_reader_buffer_timedwait(re_" + p.alias + "_, &ts, &pbuf);\n")
                s.write("        ros::Time read_time = rtt_rosclock::host_now();\n")
                s.write("        double read_interval = (read_time - update_time).toSec();\n")
                s.write("        if (read_status == SHM_TIMEOUT) {\n")
                s.write("            diag_buf_valid_ = false;\n")
                s.write("            last_read_successful_ = false;\n")
                s.write("            // do not wait\n")
                s.write("        }\n")
                s.write("        else if (read_status == 0 && ((buf = reinterpret_cast<" + p.getTypeCpp() + "*>( pbuf )) != buf_prev_" + p.alias + "_)) {\n")
                s.write("            diag_buf_valid_ = true;\n")
                s.write("            last_read_successful_ = true;\n")
                s.write("            // save the pointer of buffer\n")
                s.write("            buf_prev_" + p.alias + "_ = buf;\n")
                s.write("            port_" + p.alias + "_out_.write(*buf);\n")
                s.write("            if (read_interval < period_min_) {\n")
                s.write("                usleep_time = int((period_min_ - read_interval)*1000000.0);\n")
                s.write("            }\n")
                s.write("        }\n")
                s.write("        else if (read_status > 0) {\n")
                s.write("            diag_buf_valid_ = false;\n")
                s.write("            last_read_successful_ = false;\n")
                s.write("            if (read_interval < period_avg_) {\n")
                s.write("                usleep_time = int((period_avg_ - read_interval)*1000000.0);\n")
                s.write("            }\n")
                s.write("        }\n")
                s.write("        else {\n")
                s.write("            diag_buf_valid_ = false;\n")
                s.write("            Logger::log() << Logger::Error << getName() << \" shm_reader_buffer_timedwait(" + p.alias + ") status: \" << read_status << Logger::endl;\n")
                s.write("            error();\n")
                s.write("            return;\n")
                s.write("        }\n")
                s.write("      }\n")

    for p in sd.ports_in:
        if not sd.trigger.buffer_aliases or (not p.alias in sd.trigger.buffer_aliases):
            s.write("      {\n")
            s.write("        void *pbuf = NULL;\n")
            s.write("        read_status = shm_reader_buffer_get(re_" + p.alias + "_, &pbuf);\n")
            s.write("        " + p.getTypeCpp() + " *buf = NULL;\n")
            s.write("        if (read_status == 0 && ((buf = reinterpret_cast<" + p.getTypeCpp() + "*>( pbuf )) != buf_prev_" + p.alias + "_)) {\n")
#            s.write("            diag_buf_valid_ = true;\n")
            s.write("            // save the pointer of buffer\n")
            s.write("            buf_prev_" + p.alias + "_ = buf;\n")
            s.write("            port_" + p.alias + "_out_.write(*buf);\n")
            s.write("        }\n")
            s.write("        else if (read_status > 0) {\n")
#            s.write("            diag_buf_valid_ = false;\n")
            s.write("        }\n")
            s.write("        else {\n")
            #s.write("            diag_buf_valid_ = false;\n")
            s.write("            Logger::log() << Logger::Error << getName() << \" shm_reader_buffer_get(" + p.alias + ") status: \" << read_status << Logger::endl;\n")
            s.write("            error();\n")
            s.write("            return;\n")
            s.write("        }\n")
            s.write("      }\n")

    s.write("        trigger_out_.write(true);\n")

    if sd.trigger.buffer_aliases:
        s.write("        if (usleep_time > 0) {\n")
        s.write("            usleep(usleep_time);\n")
        s.write("        }\n")
    else:
        s.write("        usleep(" + str(int(sd.trigger.period*1000000.0)) + ");\n")

#    s.write("        else {  // if (event_)
#    s.write("            double timeout_s = 1.0;

#    s.write("            int timeout_sec = (int)timeout_s;
#    s.write("            int timeout_nsec = (int)((timeout_s - (double)timeout_sec) * 1000000000.0);

#    s.write("            ts.tv_sec += timeout_sec;
#    s.write("            ts.tv_nsec += timeout_nsec;
#    s.write("            if (ts.tv_nsec >= 1000000000) {
#    s.write("                ts.tv_nsec -= 1000000000;
#    s.write("                ++ts.tv_sec;
#    s.write("            }

#    s.write("            int read_status = shm_reader_buffer_timedwait(re_, &ts, &pbuf);

#    s.write("            if (read_status == SHM_TIMEOUT) {
#    s.write("                diag_buf_valid_ = false;
#    s.write("            }
#    s.write("            else if (read_status == 0 && ((buf = reinterpret_cast<" + p.getTypeCpp() + "*>( pbuf )) != buf_prev_)) {
#    s.write("                diag_buf_valid_ = true;
#    s.write("                // save the pointer of buffer
#    s.write("                buf_prev_ = buf;
#    s.write("                port_msg_out_.write(*buf);
#    s.write("            }
#    s.write("            else if (read_status > 0) {
#    s.write("                diag_buf_valid_ = false;
#    s.write("            }
#    s.write("            else {
#    s.write("                diag_buf_valid_ = false;
#    s.write("                Logger::log() << Logger::Error << getName() << " shm_reader_buffer_timedwait status: " << read_status << Logger::endl;
#    s.write("                error();
#    s.write("                return;
#    s.write("            }
#    s.write("        }

    s.write("        trigger();\n")
    s.write("    }\n\n")

    s.write("private:\n")

    s.write("    // properties\n")
    for p in sd.ports_in:
        s.write("    std::string param_channel_name_" + p.alias + "_;\n")

    if sd.trigger.buffer_aliases:
        s.write("    double period_min_;\n")
        s.write("    double period_avg_;\n")
        s.write("    double period_max_;\n")
        s.write("    double period_sim_max_;\n")

    for p in sd.ports_in:
        s.write("    std::string shm_name_" + p.alias + "_;\n")
        s.write("    shm_reader_t* re_" + p.alias + "_;\n")
        s.write("    " + p.getTypeCpp() + " *buf_prev_" + p.alias + "_;\n")
        s.write("    RTT::OutputPort<" + p.getTypeCpp() + " > port_" + p.alias + "_out_;\n")

    s.write("    bool last_read_successful_;\n")
    s.write("    RTT::OutputPort<bool > trigger_out_;\n")

    s.write("    bool diag_buf_valid_;\n")

    s.write("    RTT::os::TimeService::nsecs last_recv_time_;\n")

    s.write("    ros::Time last_update_time_;\n")
    s.write("};\n\n")

    s.write("};  // namespace " + package + "_types\n\n")

    s.write("ORO_LIST_COMPONENT_TYPE(" + package + "_types::InputBuffers)\n")

    (output_dir,filename) = os.path.split(output_cpp)
    try:
        os.makedirs(output_dir)
    except OSError, e:
        pass

    f = open(output_cpp, 'w')
    print >> f, s.getvalue()

    s.close()


def create_boost_headers(argv, stdout, stderr):
    parser = argparse.ArgumentParser(description='Generate boost serialization header for ROS message.')
    parser.add_argument('pkg',metavar='PKG',type=str, nargs=1,help='The package name.')
    parser.add_argument('port_def',metavar='PORT_DEF',type=str, nargs=1,help='Port definition file.')
    parser.add_argument('output_cpp',metavar='OUTPUT_CPP',type=str, nargs=1,help='Output cpp file.')

    args = parser.parse_args()

    print args.pkg[0], args.port_def[0], args.output_cpp[0]

    generate_boost_serialization(args.pkg[0], args.port_def[0], args.output_cpp[0])

if __name__ == "__main__":
    try:
        create_boost_headers(sys.argv, sys.stdout, sys.stderr)
    except Exception, e:
        sys.stderr.write("Failed to generate boost headers: " + str(e))
        raise
        #sys.exit(1)
